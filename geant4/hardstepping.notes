The current state of things:

== Current tracking engine
-----
G4SteppingManager
	GetProcessManager()
		Get{AtRest, AlongStep, PostStep}ProcessVector()
                  
		For every AtRest process
		    ::AtRestGPIL() (virtual)

		For every AlongStep() process
		    ::AlongStepGPIL (virtual)

		For every PostStep() process
		    ::PostStepGPIL (virtual)
-----		    		  

Analysis
-----
--- Multiple scattering ---
G4VMultipleScattering
	AlongStepGPIL()
		YES (note: the model is selected based on ekin)
	PostStepGPIL()
		NO (it just returns DBL_MAX)
	G4eMultipleScattering()
		It does NOT override any of the base class methods


--- Ionisation ---
G4VContinuousDiscreteProcess
	virtual AtRestGPIL()
			return -1.0;
	virtual AlongStepGPIL()
			NO
		PostStepGPIL()
			YES		
		G4VEnergyLossProcess
			AlongStepGPIL()
				YES
			PostStepGPIL()
				YES
			GeIonisation
				It does NOT override any of the
				base class methods
-----

== Overhead of a virtual function call

We used DTrace to (indirectly) estimate the *magnitude* of the overhead for
dynamic dispatching in g\++ generated code. In the favorable case a call to a
virtual function is just an indirect function call. This we cannot measure,
because we cannot distinguish it from any other indirect function call, like
(*fp)(). But, it should be fast anyway.

In more complex scenarios with multiple / virtual inheritance, g++ generates
some "wrapper" functions called "thunks". Since these are functions, we can
hook into their entry / return points and measure their overhead. I did some
calculations and the time spent is < 10 msec for 500 simulated events in the
SimplifiedCalorimeter. Similar results for FullCMS.

== Other micro-optimizations

1. Save the results of a many de-references outside of loops and
reuse them, to avoid data cache misses.
2. Used the __builtin_expect() method of g++ to emit instructions
that would cause branch prediction to favor the "likely" side of a
jump instruction.

== Side benefits

Demo here:

To list all the physics processes for electrons:
-----
root:novice/N00-build# ./listProcs | grep e-
e-                     lepton          Transportation
e-                     lepton          msc
e-                     lepton          eIoni
e-                     lepton          eBrem
e-                     lepton          ElectroNuclear
root:novice/N00-build#
-----

To list the 10 first physics process sorted alphabetically
-----
root:novice/N00-build# ./listProcs | awk '{ print $3 }' | sort | uniq | head -n10
annihil
AntiLambdaInelastic
AntiNeutronInelastic
AntiOmegaMinusInelastic
AntiProtonInelastic
AntiSigmaMinusInelastic
AntiSigmaPlusInelastic
AntiXiMinusInelastic
AntiXiZeroInelastic
root:novice/N00-build#
-----

If a non-existent physics list is given, the program will output all supported
physics lists:
-----
root:novice/N00-build# ./listProcs doesntexist
Using Physics List: 'doesntexist'

[... snip ...]

ERROR Physics List: 'doesntexist' does NOT exist
Usage: ./listProcs [<Physics List>]
                --- Available Physics Lists ---
CHIPS           FTFP_BERT       FTFP_BERT_TRV   FTF_BIC
LBE             LHEP            QBBC            QGSC_BERT
QGSP            QGSP_BERT       QGSP_BERT_CHIPS QGSP_BERT_HP
QGSP_BIC        QGSP_BIC_HP     QGSP_FTFP_BERT  QGS_BIC
QGSP_INCLXX     QGSP_INCL_ABLA  Shielding
root:novice/N00-build#
-----
